package com.inverita.vpnapptask.utils;

import android.content.Context;
import android.os.AsyncTask;

import com.inverita.vpnapptask.R;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ConnectException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.URL;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.util.Locale;

/**
 * This class is needed to mainTest is current internet connection are working or not.
 */
public class InternetTester {

    private static final int DNS_PORT = 53;
    private static final int HTTPS_PORT = 443;
    private static final int TIMEOUT = 1000;

    /**
     * Identifier: A 16-bit identification field generated by the device that creates the DNS query.
     * It is copied by the server into the response, so it can be used by that device to match that
     * query to the corresponding reply received from a DNS server. This is used in a manner similar
     * to how the Identifier field is used in many of the ICMP message types.
     */
    private static final int IDENTIFIER = 0x1234;
    private static final int WRITE_QUERY_FLAGS = 0x0100;
    /**
     * Question Count: Specifies the number of questions in the Question section of the message.
     */
    private static final int QUESTION_COUNT = 0x0001;
    /**
     * Answer Record Count: Specifies the number of resource records in the Answer section of the
     * message.
     */
    private static final int ANSWER_RECORD_COUNT = 0x0000;
    /**
     * Authority Record Count: Specifies the number of resource records in the Authority section of
     * the message. (“NS” stands for “name server”)
     */
    private static final int AUTHORITY_RECORD_COUNT = 0x0000;
    /**
     * Additional Record Count: Specifies the number of resource records in the Additional section
     * of the message.
     */
    private static final int ADDITIONAL_RECORD_COUNT = 0x0000;
    private static final int NO_MORE_PARTS = 0x00;

    /**
     * Type 0x01 = A (Host Request).
     */
    private static final int TYPE_01 = 0x0001;

    /**
     * Class 0x01 = IN.
     */
    private static final int CLASS_01 = 0x0001;

    private static final int BIG_BUFFER_SIZE = 1024;
    private static final String DOMAIN_TO_SEEK = "google.com";
    private static final int INVERT_BYTE = 0b11111111;

    private final Context context;
    private final TesterListener testerListener;

    public InternetTester(final Context context, final TesterListener testerListener) {
        this.testerListener = testerListener;
        this.context = context;
    }

    /**
     * Function for launching main DNS and HTTPS port test.
     *
     * @return Returns is test finished successfully or not.
     */
    public boolean mainTest() {
        boolean result = false;
        testerListener.onTestStarted();
        for (String address : context.getResources().getStringArray(R.array.ip_addresses)) {
            testerListener.onAddressChanged(address);
            final boolean dnsResult = testDNSPort(address);
            testerListener.onDNSResultReceived(dnsResult);
            final boolean httpsResult = testHttpsPort(address);
            testerListener.onHttpsResultReceived(httpsResult);
            if (dnsResult && httpsResult) {
                result = true;
                break;
            }
        }
        return result;
    }

    private boolean testDNSPort(final String address) {
        boolean result = false;
        final InetAddress ipAddress = getInetAddressFromString(address);
        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
        final DataOutputStream dos = new DataOutputStream(baos);

        try {
            buildDNSRequestFrame(dos);
            final byte[] dnsFrame = baos.toByteArray();
            System.out.println("Sending: " + dnsFrame.length + " bytes");
            for (byte dnsFramePart : dnsFrame) {
                System.out.print("0x" + String.format("%x", dnsFramePart) + " ");
            }
            final DatagramSocket socket = sendDNSRequestFrame(ipAddress, dnsFrame);
            final byte[] buffer = new byte[BIG_BUFFER_SIZE];
            final DatagramPacket packet = awaitResponseFromDNSServer(socket, buffer);
            System.out.println("\n\nReceived: " + packet.getLength() + " bytes");
            for (int offset = 0; offset < packet.getLength(); offset++) {
                System.out.print("0x" + String.format("%x", buffer[offset]) + " ");
            }
            System.out.println("\n");

            parseDNSResponse(buffer);
            result = true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return result;
    }

    private InetAddress getInetAddressFromString(final String address) {
        InetAddress ipAddress = null;
        try {
            ipAddress = InetAddress.getByName(address);
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
        return ipAddress;
    }

    private void buildDNSRequestFrame(final DataOutputStream dos) throws IOException {
        dos.writeShort(IDENTIFIER);
        dos.writeShort(WRITE_QUERY_FLAGS);
        dos.writeShort(QUESTION_COUNT);
        dos.writeShort(ANSWER_RECORD_COUNT);
        dos.writeShort(AUTHORITY_RECORD_COUNT);
        dos.writeShort(ADDITIONAL_RECORD_COUNT);
        final String[] domainParts = DOMAIN_TO_SEEK.split("\\.");
        System.out.println(DOMAIN_TO_SEEK + " has " + domainParts.length + " parts");
        for (String domainPart : domainParts) {
            System.out.println("Writing: " + domainPart);
            final byte[] domainBytes = domainPart.getBytes(StandardCharsets.UTF_8);
            dos.writeByte(domainBytes.length);
            dos.write(domainBytes);
        }
        dos.writeByte(NO_MORE_PARTS);
        dos.writeShort(TYPE_01);
        dos.writeShort(CLASS_01);
    }

    private DatagramSocket sendDNSRequestFrame(final InetAddress ipAddress,
                                               final byte[] dnsFrame) throws IOException {
        final DatagramSocket socket = new DatagramSocket();
        socket.setSoTimeout(TIMEOUT);
        final DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length, ipAddress, DNS_PORT);
        socket.send(dnsReqPacket);
        return socket;
    }

    private DatagramPacket awaitResponseFromDNSServer(final DatagramSocket socket,
                                                      final byte[] buffer) throws IOException {
        final DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
        socket.receive(packet);
        return packet;
    }

    private void parseDNSResponse(final byte[] buffer) throws IOException {
        final DataInputStream din = new DataInputStream(new ByteArrayInputStream(buffer));
        System.out.println("Transaction ID: 0x" + String.format("%x", din.readShort()));
        System.out.println("Flags: 0x" + String.format("%x", din.readShort()));
        System.out.println("Questions: 0x" + String.format("%x", din.readShort()));
        System.out.println("Answers RRs: 0x" + String.format("%x", din.readShort()));
        System.out.println("Authority RRs: 0x" + String.format("%x", din.readShort()));
        System.out.println("Additional RRs: 0x" + String.format("%x", din.readShort()));
        readAllRecords(din);
        System.out.println("Record Type: 0x" + String.format("%x", din.readShort()));
        System.out.println("Class: 0x" + String.format("%x", din.readShort()));
        System.out.println("Field: 0x" + String.format("%x", din.readShort()));
        System.out.println("Type: 0x" + String.format("%x", din.readShort()));
        System.out.println("Class: 0x" + String.format("%x", din.readShort()));
        System.out.println("TTL: 0x" + String.format("%x", din.readInt()));

        final short addrLen = din.readShort();
        System.out.println("Len: 0x" + String.format("%x", addrLen));
        parseAddress(din, addrLen);
    }

    private void readAllRecords(final DataInputStream din) throws IOException {
        int recLen;
        while ((recLen = din.readByte()) > 0) {
            final byte[] record = new byte[recLen];
            for (int offset = 0; offset < recLen; offset++) {
                record[offset] = din.readByte();
            }
            System.out.println("Record: " + new String(record, StandardCharsets.UTF_8));
        }
    }

    private void parseAddress(final DataInputStream din, final short addrLen) throws IOException {
        final int[] array = new int[addrLen];
        for (int addrPart = 0; addrPart < addrLen; addrPart++) {
            array[addrPart] = din.readByte() & INVERT_BYTE;
        }
        System.out.println(String.format(Locale.getDefault(),
            "Address: %d.%d.%d.%d", array[0], array[1], array[2], array[3]));
    }

    private boolean testHttpsPort(final String address) {
        boolean result;
        try {
            final Socket socket = new Socket();
            socket.connect(new InetSocketAddress(address, HTTPS_PORT), TIMEOUT);
            socket.close();
            result = true;
        } catch (ConnectException e) {
            result = false;
        } catch (Exception e) {
            result = false;
        }
        return result;
    }

    /**
     * Method requests your current external IP address.
     */
    public void getMyOwnIP() {
        final String hostname = "http://ifconfig.co/ip";
        new GetUrlContentTask().execute(hostname);
    }

    /**
     * This AsyncTask class is needed to send request for getting current external IP address.
     */
    private class GetUrlContentTask extends AsyncTask<String, Integer, String> {

        static final int TIMEOUT = 5000;

        protected String doInBackground(final String... urls) {
            final StringBuilder content = new StringBuilder();
            try {
                final URL url = new URL(urls[0]);
                final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                connection.setRequestMethod("GET");
                connection.setConnectTimeout(TIMEOUT);
                connection.setReadTimeout(TIMEOUT);
                connection.connect();
                final BufferedReader rd = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                String line;
                while ((line = rd.readLine()) != null) {
                    content.append(line).append("\n");
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            return content.toString();
        }

        protected void onPostExecute(final String result) {
            testerListener.onExternalIPReceived(result);
        }
    }
}
